!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("BasePlugin",[],n):"object"==typeof exports?exports.BasePlugin=n():e.BasePlugin=n()}(window,function(){return function(e){var n={};function t(s){if(n[s])return n[s].exports;var i=n[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,s){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:s})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(t.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(s,i,function(n){return e[n]}.bind(null,i));return s},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./main.js")}({"./main.js":function(module,exports){eval("/**\n* @author       Leonardo Farroco <leonardo.farroco@gmail.com>\n* @copyright    2018 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n*/\n\nvar AnimChar = function (scene) {\n    //  The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted) {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//  Static function called by the PluginFile Loader.\nAnimChar.register = function (PluginManager) {\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('BasePlugin', AnimChar, 'base');\n};\n\nAnimChar.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function () {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //  A test method.\n    test: function (name) {\n        console.log('BasePlugin says hello ' + name + '!');\n    },\n\n    //  Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function () {\n    },\n\n    //  Called every Scene step - phase 1\n    preUpdate: function (time, delta) {\n    },\n\n    //  Called every Scene step - phase 2\n    update: function (time, delta) {\n    },\n\n    //  Called every Scene step - phase 3\n    postUpdate: function (time, delta) {\n    },\n\n    //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function () {\n    },\n\n    //  Called when a Scene is resumed from a paused state.\n    resume: function () {\n    },\n\n    //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function () {\n    },\n\n    //  Called when a Scene is woken from a sleeping state.\n    wake: function () {\n    },\n\n    //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function () {\n    },\n\n    //  Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function () {\n        this.shutdown();\n\n        this.scene = undefined;\n    }\n\n};\n\nAnimChar.prototype.constructor = AnimChar;\n\n\nmodule.exports = AnimChar;\n\n//# sourceURL=webpack://BasePlugin/./main.js?")}})});